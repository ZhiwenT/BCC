---
title: "MixedTypeData"
author: "Zhiwen Tan"
output: 
  rmarkdown::html_vignette:
    toc: true
    number_sections: false
vignette: >
  %\VignetteIndexEntry{MixedTypeData}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

`BCClong` is an R package for performing Bayesian Consensus Clustering (BCC) model for clustering continuous, discrete and categorical longitudinal data, which are commonly seen in many clinical studies. This document gives a tour of BCClong package.

see `help(package = "BCClong")` for more information and references provided by `citation("BCClong")`

To download **BCClong**, use the following commands:

``` r
require("devtools")
devtools::install_github("ZhiwenT/BCClong", build_vignettes = TRUE)
library("BCClong")
```
To list all functions available in this package:

```r
ls("package:BCClong")
```

## Components

Currently, there are 1 function __*BCC.multi*__ in this package which will provide a summary statistics for the computed model. To use this function, the input dataset requires some pre-process. Here, we are given an example to provide an work flow for this package.

## Pre-process (Setting up)

In this example, the `PBCseq` data in the `mixAK` package was used as it is a public data set. We are only interested in the data before 910 days (2.5 years) for clustering. After 910 days (2.5 years), we are interested in comparing the survival between the two clusters. The variables used here include lbili, lsgot, and spiders. Of these three variables, lbili and lsgot are continuous variables, while spiders are categorical variables.

```{r, warning=F, message=F}
library(mixAK)
library(ggplot2)
library(cowplot)

data(PBCseq);head(PBCseq)
# patients known to be alive  and without liver transplantation at 910 days of follow-up
idx <- unique(PBCseq[PBCseq$alive>910,]$id); length(idx)
dnew910 <- PBCseq[PBCseq$id %in% idx,]; length(unique(dnew910$id))
dnew910$time <-  dnew910$month
dnew910$time <-  dnew910$month - mean(dnew910$month,na.rm=TRUE)
dnew910$time2 <-  dnew910$time^2

# use only data before 910 days (2.5 years)
dnew910.before <- dnew910[dnew910$day<=910,]; length(unique(dnew910.before$id))

# create a new ID variable with values from 1 to N;
subj <- unique(dnew910.before$id)
N <- length(subj)
id.new <- NULL
for (i in 1:N) {id.new   <- c(id.new, 
                              rep(i,length(dnew910.before[dnew910.before$id==subj[i],]$id)))}
dnew910.before$id.new <- id.new
```

## Fit BCC Model Using BCC.multi Function

Here, We used a binomial distribution for spiders marker, and a gaussian distribution for the lbili and lsgot marker, respectively. The number of clusters was set to 2. For the hyper-parameters of the adherence parameters $\alpha_r$, we set $\delta_{1,r} = \delta_{2,r} = 1$ for $r = 1,2,3$ For the global clustering proportion $\pi$, we set $\varphi = (1,...,1)$ which reflects no priori information favouring one cluster over the other. For the fixed effect coefficients $\gamma_{k,r}$, we are setting the value to list(1,1,1). For random effect $\theta$, we are setting the value to list(1,1,1).

We ran the model with 12,000 iterations, discard the first 2,000 sample, and kept every 10th sample. This resulted in 1,000 samples for each model parameter. The MCMC sampling process took about 30 minutes on an AMD Ryzen$^{TM}$ 5 5600X desktop computer.

Since this program takes a long time to run, here we will use the pre-compile result in this example. The pre-compiled data file can be found here (`./inst/extdata/PBCseq.rds`)

```r
set.seed(2002)
fit.BCC <- BCClong::BCC.multi (
  mydat = list(dnew910.before$lbili,dnew910.before$lsgot,dnew910.before$spiders),
  dist = c("gaussian","gaussian","binomial"),
  id = list(dnew910.before$id.new,dnew910.before$id.new,dnew910.before$id.new),
  time = list(dnew910.before$time,dnew910.before$time,dnew910.before$time),
  formula =list(y ~ time +  (1|id),
                y ~ time +  (1|id),
                y ~ time +  (1|id)),
  num.cluster = 2,
  hyper.par  = list(delta=1,a.star=1,b.star=1,
  aa0=0.001, bb0=0.001, ww0=0,vv0=25, cc0=0.001, dd0=0.001,rr0=4,RR0=3),
  sigma.sq.e.common = 1, 	
  c.ga.tuning = list(1,1,1),		  # tuning parameter for MH algorithm (fixed effect parameters), each parameter corresponds to an outcome/marker		
  c.theta.tuning = list(1,1,1),		# tuning parameter for MH algorithm (random effect), each parameter corresponds to an outcome/marker
  adaptive.tuning = 0,	      		# adaptive tuning parameters, 1 - yes, 0 - no
  align.clusters=0,			# assign clusters	 
  alpha.common=0,				# 1 - common alpha, 0 - separate alphas for each outcome
  sig.var = 0,				# 1 - unstructured random effect variance, 0 - diagonal random effect variance structure
  initials= NULL,			# initial values for model parameters
  initial.cluster.membership = "mixAK", # "mixAK" or "random"
  print.info="FALSE",
  burn.in = 2000, 			# number of samples discarded
  thin = 10, 				# thinning
  per = 100, 				# output information every "per" iteration 
  max.iter = 12000) 			# maximum number of iteration 
```

To run the pre-compiled result, please download the PBCseq.rds object from github under `inst/extdata/` folder. Then run the following code.

```{r, warning=F, message=F}
# pre-compiled result
fit.BCC <- readRDS("../inst/extdata/PBCseq.rds")
```

To print the summary statistics for all parameters 

```r
fit.BCC$summary.stat
```

To print the proportion \pi for each cluster (mean, sd, 2.5% and 97.5% percentile)
geweke statistics (geweke.stat) between -2 and 2 suggests the parameters converge

```r
fit.BCC$summary.stat$PPI
```

To make a trace plot for PPI to inspect convergence 

```{r, fig.height=5, fig.width=8, warning=F, message=F, fig.cap="Figure 1. Inspect convergence"}
num.sample <- (fit.BCC$max.iter -  fit.BCC$burn.in)/fit.BCC$thin # number of MCMC sample
par(mfrow=c(1,2))
plot(1:num.sample,fit.BCC$PPI[,1],type="l",col="blue" ,
     xlab="MCMC iterations",ylab=expression(pi[1]),main= expression(paste("Trace of ",pi[1],sep="")),
     cex.lab=1.6,cex.axis=1.6,cex.main=2)
plot(1:num.sample,fit.BCC$PPI[,2],type="l",col="blue" ,
     xlab="MCMC iterations",ylab=expression(pi[2]),main= expression(paste("Trace of ",pi[2],sep="")),
     cex.lab=1.6,cex.axis=1.6,cex.main=2)
```

Same thing can be done for the adherence parameters alpha for each marker

```{r, fig.height=5, fig.width=8, warning=F, message=F, fig.cap="Figure 2. adherence parameters alpha for each marker"}
fit.BCC$summary.stat$ALPHA

# making a trace plot for alpha to inspect convergence 
par(mfrow=c(1,3))
plot(1:num.sample,fit.BCC$ALPHA[,1],type="l",col="blue" ,
     xlab="MCMC iterations",ylab=expression(alpha[1]),main= expression(paste("Trace of ",alpha[1],sep="")),
     cex.lab=1.6,cex.axis=1.6,cex.main=2)
plot(1:num.sample,fit.BCC$ALPHA[,2],type="l",col="blue" ,
     xlab="MCMC iterations",ylab=expression(alpha[2]),main= expression(paste("Trace of ",alpha[2],sep="")),
     cex.lab=1.6,cex.axis=1.6,cex.main=2)
plot(1:num.sample,fit.BCC$ALPHA[,3],type="l",col="blue" ,
     xlab="MCMC iterations",ylab=expression(alpha[2]),main= expression(paste("Trace of ",alpha[3],sep="")),
     cex.lab=1.6,cex.axis=1.6,cex.main=2)
```

## Visualize Clusters

To plot the results, `ggplot2` and `cowplot` are used here. Other plotting methods can also be used, here is just an example. From the following code, we can get 6 plots for 3 markers, each marker has a plot for local clustering and a plot for global clustering. 

```{r, fig.height=15, fig.width=8, warning=F, message=F, fig.cap = "Figure 3. Local and global clustering"}
dat <- fit.BCC$dat
dat[[1]]$time.org <- dat[[1]]$time + mean(dnew910$month,na.rm=TRUE) # transform the time back to the original scale

# For the first marker by local clustering
dat[[1]]$cluster.local <- factor(dat[[1]]$cluster.local,label=c("Cluster 1","Cluster 2"))
gp1 <- ggplot(data = dat[[1]], aes(x =time.org, y =y, color=cluster.local,linetype=cluster.local,fill=cluster.local))+
  labs(caption = "Local clustering for lbili marker")+
  geom_point(size=2,alpha=0.2) +
  geom_line(aes(x = time.org, y = y,group=id,color=cluster.local),size=1.5,alpha=0.2)+ 
  geom_smooth(method = "loess", size = 3,se = FALSE,span=2) +
  ggtitle(expression(paste("lbili (",hat(alpha), " = 0.98 )", sep=""))) + 
  theme_bw() + 
  ylab("lbili") + xlab("months")+
  theme(legend.position ="bottom",legend.key.size = unit(0.5, 'cm'),
        legend.title=element_blank(),
        plot.title = element_text(size = 16, face = "bold"),
        axis.text=element_text(size=16),
        axis.title=element_text(size=16),
        legend.text=element_text(size=8),
        axis.text.x = element_text(angle = 0 ),
        strip.text.x = element_text(size = 16, angle = 0),
        strip.text.y = element_text(size = 16,face="bold")) +
  guides(color=guide_legend(nrow=2,byrow=TRUE), linetype=guide_legend(nrow=2,byrow=TRUE),fill=guide_legend(nrow=2,byrow=TRUE)) 


# For the second marker by local clustering
dat[[2]]$cluster.local <- factor(dat[[2]]$cluster.local,label=c("Cluster 1","Cluster 2"))
dat[[2]]$time.org <- dat[[2]]$time + mean(dnew910$month,na.rm=TRUE) # transform the time back to the original scale

gp2 <- ggplot(data = dat[[2]], aes(x =time.org, y =y, color=cluster.local,linetype=cluster.local,fill=cluster.local))+
  labs(caption = "Local clustering for lsgot marker")+
  geom_point(size=2,alpha=0.2) +
  geom_line(aes(x = time.org, y = y,group=id,color=cluster.local),size=1.5,alpha=0.2)+ 
  geom_smooth(method = "loess", size = 3,se = FALSE,span=2) +
  ggtitle(expression(paste("lsgot (",hat(alpha), " = 0.79 )", sep=""))) + 
  theme_bw() + 
  ylab("lsgot") + xlab("months")+
  theme(legend.position ="bottom",legend.key.size = unit(0.5, 'cm'),
        legend.title=element_blank(),
        plot.title = element_text(size = 16, face = "bold"),
        axis.text=element_text(size=16),
        axis.title=element_text(size=16),
        legend.text=element_text(size=8),
        axis.text.x = element_text(angle = 0 ),
        strip.text.x = element_text(size = 16, angle = 0),
        strip.text.y = element_text(size = 16,face="bold")) +
  guides(color=guide_legend(nrow=2,byrow=TRUE), linetype=guide_legend(nrow=2,byrow=TRUE),fill=guide_legend(nrow=2,byrow=TRUE)) 

# For the third marker by local clustering
dat[[3]]$cluster.local <- factor(dat[[3]]$cluster.local,label=c("Cluster 1","Cluster 2"))
dat[[3]]$time.org <- dat[[3]]$time + mean(dnew910$month,na.rm=TRUE) # transform the time back to the original scale

gp3 <- ggplot(data = dat[[3]], aes(x =time.org, y =y, color=cluster.local,linetype=cluster.local,fill=cluster.local))+
  labs(caption = "Local clustering for spiders marker")+
  geom_point(size=2,alpha=0.5) +
  geom_smooth(method = "loess", size = 3,se = FALSE,span=2) +
  geom_line(aes(x = time.org, y = y,group=id,color=cluster.local),size=1.5,alpha=0.2)+ 
  ggtitle(expression(paste("spiders (",hat(alpha), " = 0.75 )", sep=""))) + 
  theme_bw() + 
  ylab("spiders") + xlab("months")+
  theme(legend.position ="bottom",legend.key.size = unit(0.5, 'cm'),
        legend.title=element_blank(),
        plot.title = element_text(size = 16, face = "bold"),
        axis.text=element_text(size=16),
        axis.title=element_text(size=16),
        legend.text=element_text(size=8),
        axis.text.x = element_text(angle = 0 ),
        strip.text.x = element_text(size = 16, angle = 0),
        strip.text.y = element_text(size = 16,face="bold")) +
  guides(color=guide_legend(nrow=2,byrow=TRUE), linetype=guide_legend(nrow=2,byrow=TRUE),fill=guide_legend(nrow=2,byrow=TRUE)) 


# For the first marker by global(consensus) clustering
dat[[1]]$cluster.global <- factor(dat[[1]]$cluster.global,label=c("Cluster 1","Cluster 2"))
gp4 <- ggplot(data = dat[[1]], aes(x =time.org, y =y, color=cluster.global,linetype=cluster.global,fill=cluster.global))+
  labs(caption = "Global clustering for lbili marker")+
  geom_point(size=2,alpha=0.2) +
  geom_line(aes(x = time.org, y = y,group=id,color=cluster.global),size=1.5,alpha=0.2)+ 
  geom_smooth(method = "loess", size = 3,se = FALSE,span=2) +
  ggtitle("lbili") + 
  theme_bw() + 
  ylab("lbili") + xlab("months")+
  theme(legend.position ="bottom",legend.key.size = unit(0.5, 'cm'),
        legend.title=element_blank(),
        plot.title = element_text(size = 16),
        axis.text=element_text(size=16),
        axis.title=element_text(size=16),
        legend.text=element_text(size=8),
        axis.text.x = element_text(angle = 0 ),
        strip.text.x = element_text(size = 16, angle = 0),
        strip.text.y = element_text(size = 16,face="bold")) +
  guides(color=guide_legend(nrow=2,byrow=TRUE), linetype=guide_legend(nrow=2,byrow=TRUE),fill=guide_legend(nrow=2,byrow=TRUE)) 


# For the second marker by global(consensus) clustering
dat[[2]]$cluster.global <- factor(dat[[2]]$cluster.global,label=c("Cluster 1","Cluster 2"))
gp5 <- ggplot(data = dat[[2]], aes(x =time.org, y = y, color=cluster.global,linetype=cluster.global,fill=cluster.global))+
  labs(caption = "Global clustering for lsgot marker")+
  geom_point(size=2,alpha=0.2) +
  geom_line(aes(x = time.org, y = y,group=id,color=cluster.global),size=1.5,alpha=0.2)+ 
  geom_smooth(method = "loess", size = 3,se = FALSE,span=2)+
  ggtitle("lsgot") + 
  theme_bw() + 
  ylab("lsgot") + xlab("months")+
  theme(legend.position ="bottom",legend.key.size = unit(0.5, 'cm'),
        legend.title=element_blank(),
        plot.title = element_text(size = 16 ),
        axis.text=element_text(size=16),
        axis.title=element_text(size=16),
        legend.text=element_text(size=8),
        axis.text.x = element_text(angle = 0 ),
        strip.text.x = element_text(size = 16, angle = 0),
        strip.text.y = element_text(size = 16,face="bold"))+
  guides(color=guide_legend(nrow=2,byrow=TRUE), linetype=guide_legend(nrow=2,byrow=TRUE),fill=guide_legend(nrow=2,byrow=TRUE))   

# For the third marker by global(consensus) clustering
dat[[3]]$cluster.global <- factor(dat[[3]]$cluster.global,label=c("Cluster 1","Cluster 2"))
gp6 <- ggplot(data = dat[[3]], aes(x =time.org, y = y, color=cluster.global,linetype=cluster.global,fill=cluster.global))+
  labs(caption = "Global clustering for spiders marker")+
  geom_point(size=2,alpha=0.2) +
  geom_line(aes(x = time.org, y = y,group=id,color=cluster.global),size=1.5,alpha=0.2)+ 
  geom_smooth(method = "loess", size = 3,se = FALSE,span=2)+
  ggtitle("spiders") + 
  theme_bw() + 
  ylab("spiders") + xlab("months")+
  theme(legend.position ="bottom",legend.key.size = unit(0.5, 'cm'),
        legend.title=element_blank(),
        plot.title = element_text(size = 16),
        axis.text=element_text(size=16),
        axis.title=element_text(size=16),
        legend.text=element_text(size=8),
        axis.text.x = element_text(angle = 0 ),
        strip.text.x = element_text(size = 16, angle = 0),
        strip.text.y = element_text(size = 16,face="bold"))+
  guides(color=guide_legend(nrow=2,byrow=TRUE), linetype=guide_legend(nrow=2,byrow=TRUE),fill=guide_legend(nrow=2,byrow=TRUE))  

plot_grid(gp1,gp4,gp2, gp5,gp3,gp6, labels=c("(A)", "(B)", "(C)", "(D)", "(E)", "(F)" ), nrow = 3,   align = "v" )
```

## Survival Analysis After 910 Days

```{r, fig.height=15, fig.width=10, warning=F, message=F, fig.cap="Figure 4. Survival curve for global and local clustering"}
# Making Kaplan–Meier (KM) for survival probability after 2.5 years
library(survminer)
library(survival)

# create new ID from 1 to N - for dnew910;
subj <- unique(dnew910$id)
N <- length(subj)
id.new <- NULL
for (i in 1:N) {id.new   <- c(id.new, rep(i,length(dnew910[dnew910$id==subj[i],]$id)))}
dnew910$id.new <- id.new
dnew910_uq <- dnew910[!duplicated(dnew910$id, fromLast=TRUE),] # Keep last observation per ID


myplot <- list()
# KM Curve by local clustering for the first marker
dat[[1]]$id.new <- dat[[1]]$id
dat1 <- data.frame(id.new= dat[[1]]$id,cluster.local1 = factor(dat[[1]]$cluster.local,label=c(1,2)))
dat1_uq <- dat1[!duplicated(dat1$id.new, fromLast=TRUE),]; 
dnew910_uq <- merge(dat1_uq,dnew910_uq,by="id.new")
dnew910_uq$cluster <- dnew910_uq$cluster.local1

fit <- survfit(Surv(month, delta.death) ~  cluster,data = dnew910_uq, start.time=30.08)
myplot[[1]] <- ggsurvplot(fit, data = dnew910_uq, risk.table = TRUE,pval=TRUE,conf.int = TRUE,
                          pval.coord=c(40,0.2), xlab="months",
                          title = expression(paste("lbili (",
                                                   hat(alpha), " = 0.98 )", 
                                                   sep="")),
                          ggtheme =  theme_bw() + 
                                 theme(legend.position ="none",
                                 legend.title=element_blank(),
                                 plot.title = element_text(size = 15, face = "bold"),
                                 legend.text=element_text(size=8),
                                 axis.text=element_text(size=10),
                                 axis.title=element_text(size=10),
                                 strip.text.x = element_text(size=10),
                                 strip.text.y = element_text(size=10))) + 
  guides(colour = guide_legend(nrow = 2))+
  labs(caption = "Survival curve for lbili marker local clustering")

# KM Curve by local clustering for the second marker
dat[[2]]$id.new <- dat[[2]]$id
dat2 <- data.frame(id.new= dat[[2]]$id,cluster.local2 = factor(dat[[2]]$cluster.local,label=c(1,2)))
dat2_uq <- dat2[!duplicated(dat2$id.new, fromLast=TRUE),]; 
dnew910_uq <- merge(dat2_uq,dnew910_uq,by="id.new")
dnew910_uq$cluster <- dnew910_uq$cluster.local2

fit <- survfit(Surv(month, delta.death) ~  cluster,data = dnew910_uq,start.time=30.08)
myplot[[2]] <- ggsurvplot(fit, data = dnew910_uq, risk.table = TRUE,pval=TRUE,conf.int = TRUE,
                          pval.coord=c(40,0.2), xlab="months",title=expression(paste("lsgot (",hat(alpha), " = 0.79)", sep="")),
                          ggtheme =  theme_bw() + 
                                 theme(legend.position ="none",
                                 legend.title=element_blank(),
                                 plot.title = element_text(size = 15, face = "bold"),
                                 legend.text=element_text(size=8),
                                 axis.text=element_text(size=10),
                                 axis.title=element_text(size=10),
                                 strip.text.x = element_text(size=10),
                                 strip.text.y = element_text(size=10))) + 
  guides(colour = guide_legend(nrow = 2))+
  labs(caption = "Survival curve for lsgot marker local clustering")


#-------------------------------------------------------------------#
dat[[3]]$id.new <- dat[[3]]$id
dat3 <- data.frame(id.new= dat[[3]]$id,cluster.local3 = factor(dat[[3]]$cluster.local,label=c(1,2)))
dat3_uq <- dat3[!duplicated(dat3$id.new, fromLast=TRUE),]; 
dnew910_uq <- merge(dat3_uq,dnew910_uq,by="id.new")
dnew910_uq$cluster <- dnew910_uq$cluster.local3

fit <- survfit(Surv(month, delta.death) ~  cluster,data = dnew910_uq,start.time=30.08)
myplot[[3]] <- ggsurvplot(fit, data = dnew910_uq, risk.table = TRUE,pval=TRUE,
                          conf.int = TRUE,pval.coord=c(40,0.2),
                          xlab="months",
                          title=expression(paste("spiders (",hat(alpha), " = 0.75)", sep="")),
                          ggtheme =  theme_bw() + 
                                 theme(legend.position ="none",
                                 legend.title=element_blank(),
                                 plot.title = element_text(size = 15, face = "bold"),
                                 legend.text=element_text(size=8),
                                 axis.text=element_text(size=10),
                                 axis.title=element_text(size=10),
                                 strip.text.x = element_text(size=10),
                                 strip.text.y = element_text(size=10))) + 
  guides(colour = guide_legend(nrow = 2))+
  labs(caption = "Survival curve for spiders marker local clustering")

#-------------------------------------------------------------------#
dat <- data.frame(id.new= dat[[1]]$id,cluster.global = factor(dat[[1]]$cluster.global,label=c(1,2)))
dat_uq <- dat[!duplicated(dat$id.new, fromLast=TRUE),]; 
dnew910_uq <- merge(dat_uq,dnew910_uq,by="id.new")
dnew910_uq$cluster <- dnew910_uq$cluster.global

fit <- survfit(Surv(month, delta.death) ~  cluster,data = dnew910_uq,start.time=30.08)
myplot[[4]] <- ggsurvplot(fit, data = dnew910_uq, risk.table = TRUE,pval=TRUE,conf.int = TRUE,
                          pval.coord=c(40,0.2), xlab="months",
                          title="overall clusters", 
                          ggtheme =  theme_bw() + 
                                 theme(legend.position ="none",
                                 legend.title=element_blank(),
                                 plot.title = element_text(size = 15, face = "bold"),
                                 legend.text=element_text(size=8),
                                 axis.text=element_text(size=10),
                                 axis.title=element_text(size=10),
                                 strip.text.x = element_text(size=10),
                                 strip.text.y = element_text(size=10))) + 
  guides(colour = guide_legend(nrow = 2))+
  labs(caption = "Survival curve for global clustering")

# Arrange multiple ggsurvplots and print the output
arrange_ggsurvplots(myplot, print = TRUE, ncol = 2, nrow = 2 )


#--------------------------------------------------------------------------------#
# Cox model for the association between clusters and time to death
#--------------------------------------------------------------------------------#
# association between the local clustering of the first marker (lbili) and time to death
SurvObj <- with(dnew910_uq[dnew910_uq$alive>910,], Surv(month, delta.death == 1))
fit.coxph <- coxph(SurvObj~cluster.local1,data=dnew910_uq[dnew910_uq$alive>910,])
fit.coxph

# association between the local clustering of the second marker (lsgot) and time to death
SurvObj <- with(dnew910_uq[dnew910_uq$alive>910,], Surv(month, delta.death == 1))
fit.coxph <- coxph(SurvObj~cluster.local2 + age + sex,data=dnew910_uq[dnew910_uq$alive>910,])
fit.coxph

# association between the local clustering of the third marker (lsgot) and time to death
SurvObj <- with(dnew910_uq[dnew910_uq$alive>910,], Surv(month, delta.death == 1))
fit.coxph <- coxph(SurvObj~cluster.local3 + age + sex,data=dnew910_uq[dnew910_uq$alive>910,])
fit.coxph

# association between the global(consensus) clustering and time to death
SurvObj <- with(dnew910_uq[dnew910_uq$alive>910,], Surv(month, delta.death == 1))
fit.coxph <- coxph(SurvObj~cluster.global,data=dnew910_uq[dnew910_uq$alive>910,])
fit.coxph
```

## Package References

[Tan, Z., Shen, C., Lu, Z. (2022) BCClong: an R package for performing Bayesian Consensus Clustering model for clustering continuous, discrete and categorical longitudinal data.](https://github.com/ZhiwenT/BCClong)

```{r}
sessionInfo()
```

