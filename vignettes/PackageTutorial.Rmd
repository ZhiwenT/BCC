---
title: "PackageTutorial"
author: "Zhiwen Tan"
output: 
  rmarkdown::html_vignette:
    toc: true
    number_sections: false
vignette: >
  %\VignetteIndexEntry{PackageTutorial}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

`BCClong` is an R package for performing Bayesian Consensus Clustering (BCC) model for clustering continuous, discrete and categorical longitudinal data, which are commonly seen in many clinical studies. This document gives a tour of BCClong package.

see `help(package = "BCClong")` for more information and references provided by `citation("BCClong")`

To download **BCClong**, use the following commands:

``` r
require("devtools")
devtools::install_github("ZhiwenT/BCClong", build_vignettes = TRUE)
library("BCClong")
```
To list all functions available in this package:

```r
ls("package:BCClong")
```

## Components

Currently, there are 1 function __*BCC.multi*__ in this package which will provide a summary statistics for the computed model. To use this function, the input dataset requires some pre-process. Here, we are given an example to provide an work flow for this package.

## Pre-process (Setting up)

In this example, the PBCseq data was used as it is an public data set. We are only interested in the data before 910 days (2.5 years).

```{r}
library(mixAK)
library(ggplot2)
library(cowplot)

data(PBCseq);head(PBCseq)
# patients known to be alive  and without liver transplantation at 910 days of follow-up
idx <- unique(PBCseq[PBCseq$alive>910,]$id); length(idx)
dnew910 <- PBCseq[PBCseq$id %in% idx,]; length(unique(dnew910$id))
dnew910$time <-  dnew910$month
dnew910$time <-  dnew910$month - mean(dnew910$month,na.rm=TRUE)
dnew910$time2 <-  dnew910$time^2

# use only data before 910 days (2.5 years)
dnew910.before <- dnew910[dnew910$day<=910,]; length(unique(dnew910.before$id))

# create a new ID variable with values from 1 to N;
subj <- unique(dnew910.before$id)
N <- length(subj)
id.new <- NULL
for (i in 1:N) {id.new   <- c(id.new, 
                              rep(i,length(dnew910.before[dnew910.before$id==subj[i],]$id)))}
dnew910.before$id.new <- id.new
```

## Fit BCC Model Using BCC.multi Function

```{=latex}
Here, We used a binomial distribution for spiders marker, and a Gaussian distribution for the lbili and lsgot marker, respectively. The number of clusters was setted to 2. For the hyper-parameters of the adherence parameters \alpha_r, we set \delta_{1,r} = \delta_{2,r} = 1 for r = 1,2,3/ For the global clustering propertion \pi, we set \varphi = (1,...,1) which reflects no priori information favouring one cluster over the other. For the fixed effect coefficients \gamma_{k,r}, we are setting the value to list(1,1,1). For random effect \theta, we are setting the value to list(1,1,1).\\
We ran the model with 12,000 iterations, discard the first 2000 sample, and kept every 10th sample. This resulted in 1,000 samples for each model parameter. The MCMC sampling process tooks about 30 minutes on an AMD Ryzen^{TM} 5 5600X desktop computer.\\
Since this program takes a long time to run, here we will use the pre-compile result in this example. The pre-compiled data file can be found here (./inst/extdata/BCC.rds)
```

```r
set.seed(2002)
fit.BCC <- BCClong::BCC.multi (
  mydat = list(dnew910.before$lbili,dnew910.before$lsgot,dnew910.before$spiders),
  dist = c("gaussian","gaussian","binomial"),
  id = list(dnew910.before$id.new,dnew910.before$id.new,dnew910.before$id.new),
  time = list(dnew910.before$time,dnew910.before$time,dnew910.before$time),
  formula =list(y ~ time +  (1|id),
                y ~ time +  (1|id),
                y ~ time +  (1|id)),
  num.cluster = 2,
  hyper.par  = list(delta=1,a.star=1,b.star=1,aa0=0.001, bb0=0.001, ww0=0,vv0=25, cc0=0.001, dd0=0.001,rr0=4,RR0=3),
  sigma.sq.e.common = 1, 	
  c.ga.tuning = list(1,1,1),		    # tuning parameter for MH algorithm (fixed effect parameters), each parameter corresponds to an outcome/marker		
  c.theta.tuning = list(1,1,1),		# tuning parameter for MH algorithm (random effect), each parameter corresponds to an outcome/marker
  adaptive.tuning = 0,	      		# adaptive tuning parameters, 1 - yes, 0 - no
  align.clusters=0,			# assign clusters	 
  alpha.common=0,				# 1 - common alpha, 0 - separate alphas for each outcome
  sig.var = 0,				# 1 - unstructured random effect variance, 0 - diagonal random effect variance structure
  initials= NULL,			# initial values for model parameters
  initial.cluster.membership = "mixAK", # "mixAK" or "random"
  print.info="FALSE",
  burn.in = 2000, 			# number of samples discarded
  thin = 10, 				# thinning
  per = 100, 				# output information every "per" iteration 
  max.iter = 12000) 			# maximum number of iteration 
```
```{r}
# pre-compiled result
fit.BCC <- readRDS("../inst/extdata/BCC.rds")
```

To print the summary statistics for all parameters 

```r
fit.BCC$summary.stat
```

To print the proportion \pi for each cluster (mean, sd, 2.5% and 97.5% percentile)
geweke statistics (geweke.stat) between -2 and 2 suggests the parameters converge

```r
fit.BCC$summary.stat$PPI
```

To make a trace plot for PPI to inspect convergence 

```{r}
num.sample <- (fit.BCC$max.iter -  fit.BCC$burn.in)/fit.BCC$thin # number of MCMC sample
par(mfrow=c(1,2))
plot(1:num.sample,fit.BCC$PPI[,1],type="l",col="blue" ,
     xlab="MCMC iterations",ylab=expression(pi[1]),main= expression(paste("Trace of ",pi[1],sep="")),
     cex.lab=1.6,cex.axis=1.6,cex.main=2)
plot(1:num.sample,fit.BCC$PPI[,2],type="l",col="blue" ,
     xlab="MCMC iterations",ylab=expression(pi[2]),main= expression(paste("Trace of ",pi[2],sep="")),
     cex.lab=1.6,cex.axis=1.6,cex.main=2)
```

Same thing can be done for the adherence parameters alpha for each marker

```{r}
fit.BCC$summary.stat$ALPHA

# making a trace plot for alpha to inspect convergence 
par(mfrow=c(1,3))
plot(1:num.sample,fit.BCC$ALPHA[,1],type="l",col="blue" ,
     xlab="MCMC iterations",ylab=expression(alpha[1]),main= expression(paste("Trace of ",alpha[1],sep="")),
     cex.lab=1.6,cex.axis=1.6,cex.main=2)
plot(1:num.sample,fit.BCC$ALPHA[,2],type="l",col="blue" ,
     xlab="MCMC iterations",ylab=expression(alpha[2]),main= expression(paste("Trace of ",alpha[2],sep="")),
     cex.lab=1.6,cex.axis=1.6,cex.main=2)
plot(1:num.sample,fit.BCC$ALPHA[,3],type="l",col="blue" ,
     xlab="MCMC iterations",ylab=expression(alpha[2]),main= expression(paste("Trace of ",alpha[3],sep="")),
     cex.lab=1.6,cex.axis=1.6,cex.main=2)
```

## Visualize Clusters

To plot the results, `ggplot2` and `cowplot` are used here. Other plotting methods can also be used, here is just an example. From the following code, we can get 6 plots for 3 markers, each marker has a plot for local clustering and a plot for global clustering. 

```{r}
dat <- fit.BCC$dat
dat[[1]]$time.org <- dat[[1]]$time + mean(dnew910$month,na.rm=TRUE) # transform the time back to the orignal scale

# For the first marker by local clustering
dat[[1]]$cluster.local <- factor(dat[[1]]$cluster.local,label=c("Cluster 1","Cluster 2"))
gp1 <- ggplot(data = dat[[1]], aes(x =time.org, y =y, color=cluster.local,linetype=cluster.local,fill=cluster.local))+
  geom_point(size=2,alpha=0.2) +
  geom_line(aes(x = time.org, y = y,group=id,color=cluster.local),size=1.5,alpha=0.2)+ 
  geom_smooth(method = "loess", size = 3,se = FALSE,span=2) +
  ggtitle(expression(paste("lbili (",hat(alpha), " = 0.98 )", sep=""))) + 
  theme_bw() + 
  ylab("lbili") + xlab("months")+
  theme(legend.position =c(0.8,0.1),legend.title=element_blank(),
        plot.title = element_text(size = 16, face = "bold"),
        axis.text=element_text(size=16),
        axis.title=element_text(size=16),
        legend.text=element_text(size=10),
        axis.text.x = element_text(angle = 0 ),
        strip.text.x = element_text(size = 16, angle = 0),
        strip.text.y = element_text(size = 16,face="bold")) +
  guides(color=guide_legend(nrow=2,byrow=TRUE), linetype=guide_legend(nrow=2,byrow=TRUE),fill=guide_legend(nrow=2,byrow=TRUE)) 


# For the second marker by local clustering
dat[[2]]$cluster.local <- factor(dat[[2]]$cluster.local,label=c("Cluster 1","Cluster 2"))
dat[[2]]$time.org <- dat[[2]]$time + mean(dnew910$month,na.rm=TRUE) # transform the time back to the original scale

gp2 <- ggplot(data = dat[[2]], aes(x =time.org, y =y, color=cluster.local,linetype=cluster.local,fill=cluster.local))+
  geom_point(size=2,alpha=0.2) +
  geom_line(aes(x = time.org, y = y,group=id,color=cluster.local),size=1.5,alpha=0.2)+ 
  geom_smooth(method = "loess", size = 3,se = FALSE,span=2) +
  ggtitle(expression(paste("lsgot (",hat(alpha), " = 0.79 )", sep=""))) + 
  theme_bw() + 
  ylab("lsgot") + xlab("months")+
  theme(legend.position =c(0.8,0.1),legend.title=element_blank(),
        plot.title = element_text(size = 16, face = "bold"),
        axis.text=element_text(size=16),
        axis.title=element_text(size=16),
        legend.text=element_text(size=10),
        axis.text.x = element_text(angle = 0 ),
        strip.text.x = element_text(size = 16, angle = 0),
        strip.text.y = element_text(size = 16,face="bold")) +
  guides(color=guide_legend(nrow=2,byrow=TRUE), linetype=guide_legend(nrow=2,byrow=TRUE),fill=guide_legend(nrow=2,byrow=TRUE)) 

# For the third marker by local clustering
dat[[3]]$cluster.local <- factor(dat[[3]]$cluster.local,label=c("Cluster 1","Cluster 2"))
dat[[3]]$time.org <- dat[[3]]$time + mean(dnew910$month,na.rm=TRUE) # transform the time back to the original scale

gp3 <- ggplot(data = dat[[3]], aes(x =time.org, y =y, color=cluster.local,linetype=cluster.local,fill=cluster.local))+
  geom_point(size=2,alpha=0.5) +
  geom_smooth(method = "loess", size = 3,se = FALSE,span=2) +
  geom_line(aes(x = time.org, y = y,group=id,color=cluster.local),size=1.5,alpha=0.2)+ 
  ggtitle(expression(paste("spiders (",hat(alpha), " = 0.75 )", sep=""))) + 
  theme_bw() + 
  ylab("spiders") + xlab("months")+
  theme(legend.position =c(0.9,0.4),legend.title=element_blank(),
        plot.title = element_text(size = 16, face = "bold"),
        axis.text=element_text(size=16),
        axis.title=element_text(size=16),
        legend.text=element_text(size=10),
        axis.text.x = element_text(angle = 0 ),
        strip.text.x = element_text(size = 16, angle = 0),
        strip.text.y = element_text(size = 16,face="bold")) +
  guides(color=guide_legend(nrow=2,byrow=TRUE), linetype=guide_legend(nrow=2,byrow=TRUE),fill=guide_legend(nrow=2,byrow=TRUE)) 


# For the first marker by global(consensus) clustering
dat[[1]]$cluster.global <- factor(dat[[1]]$cluster.global)
gp4 <- ggplot(data = dat[[1]], aes(x =time.org, y =y, color=cluster.global,linetype=cluster.global,fill=cluster.global))+
  geom_point(size=2,alpha=0.2) +
  geom_line(aes(x = time.org, y = y,group=id,color=cluster.global),size=1.5,alpha=0.2)+ 
  geom_smooth(method = "loess", size = 3,se = FALSE,span=2) +
  ggtitle("lbili") + 
  theme_bw() + 
  ylab("lbili") + xlab("months")+
  theme(legend.position = "none",legend.title=element_blank(),
        plot.title = element_text(size = 16),
        axis.text=element_text(size=16),
        axis.title=element_text(size=16),
        legend.text=element_text(size=10),
        axis.text.x = element_text(angle = 0 ),
        strip.text.x = element_text(size = 16, angle = 0),
        strip.text.y = element_text(size = 16,face="bold")) +
  guides(color=guide_legend(nrow=2,byrow=TRUE), linetype=guide_legend(nrow=2,byrow=TRUE),fill=guide_legend(nrow=2,byrow=TRUE)) 


# For the second marker by global(consensus) clustering
dat[[2]]$cluster.global <- factor(dat[[2]]$cluster.global)
gp5 <- ggplot(data = dat[[2]], aes(x =time.org, y = y, color=cluster.global,linetype=cluster.global,fill=cluster.global))+
  geom_point(size=2,alpha=0.2) +
  geom_line(aes(x = time.org, y = y,group=id,color=cluster.global),size=1.5,alpha=0.2)+ 
  geom_smooth(method = "loess", size = 3,se = FALSE,span=2)+
  ggtitle("lsgot") + 
  theme_bw() + 
  ylab("lsgot") + xlab("months")+
  theme(legend.position ="none",legend.title=element_blank(),
        plot.title = element_text(size = 16 ),
        axis.text=element_text(size=16),
        axis.title=element_text(size=16),
        legend.text=element_text(size=10),
        axis.text.x = element_text(angle = 0 ),
        strip.text.x = element_text(size = 16, angle = 0),
        strip.text.y = element_text(size = 16))  

# For the third marker by global(consensus) clustering
dat[[3]]$cluster.global <- factor(dat[[3]]$cluster.global)
gp6 <- ggplot(data = dat[[3]], aes(x =time.org, y = y, color=cluster.global,linetype=cluster.global,fill=cluster.global))+
  geom_point(size=2,alpha=0.2) +
  geom_line(aes(x = time.org, y = y,group=id,color=cluster.global),size=1.5,alpha=0.2)+ 
  geom_smooth(method = "loess", size = 3,se = FALSE,span=2)+
  ggtitle("spiders") + 
  theme_bw() + 
  ylab("spiders") + xlab("months")+
  theme(legend.position ="none",legend.title=element_blank(),
        plot.title = element_text(size = 16),
        axis.text=element_text(size=16),
        axis.title=element_text(size=16),
        legend.text=element_text(size=10),
        axis.text.x = element_text(angle = 0 ),
        strip.text.x = element_text(size = 16, angle = 0),
        strip.text.y = element_text(size = 16,face="bold")) 

plot_grid(gp1,gp2,gp3, gp4,gp5,gp6, labels=c("(A)", "(B)", "(C)", "(D)", "(E)", "(F)" ), nrow = 2,   align = "v" )
```

## Package References

[Tan, Z. (2022) BCClong (Bayesian Consensus Clustering (BCC) model for mixed-type longitudinal data): an R package for performing Bayesian Consensus Clustering (BCC) model for clustering continuous, discrete and categorical longitudinal data.](https://github.com/ZhiwenT/BCClong)

```{r}
sessionInfo()
```

